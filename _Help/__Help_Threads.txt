Многопоточность — это два и более потоков, выполняющихся одновременно в одной программе.

В Java есть две возможности создания потоков:
 - расширение(extending) класса Thread. --------------------------------------------------------------------------------
   Расширение класса - это путь наследования методов и переменных класса родителя. В этом случае можно наследоваться
   только от одного родительского класса Thread.

 - реализация(implementing) интерфейса Runnable; -----------------------------------------------------------------------
   Данное ограничение внутри Java можно преодолеть реализацией интерфейса Runnable, который является наиболее
   распространённым способом создания потоков.

Потоки могут взаимодействовать друг с другом через основной «родительский» поток, из которого они стартованы.

Когда запускается любое приложение, то начинает выполняться поток, называемый главным потоком (main).
От него порождаются дочерние потоки.
Главный поток, как правило, является последним потоком, завершающим выполнение программы.

Получим информацию о главном потоке и поменяем его имя:
Thread mainThread = Thread.currentThread();
System.out.println("Текущий поток: " + mainThread.getName());

Меняем имя и выводим в текстовом поле:
mainThread.setName("CatThread");
System.out.println("\nНовое имя потока: " + mainThread.getName());

Вызовем информацию о названии потока без указания метода.
Thread mainThread = Thread.currentThread();
System.out.println("Текущий поток: " + mainThread);

В этом случае можно увидеть строчку Thread[main,5,main] - имя потока, его приоритет и имя его группы.

------------------------------------------------------------------------------------------------------------------------

Несмотря на то, что главный поток создаётся автоматически, им можно управлять через объект класса Thread.
Для этого нужно вызвать метод currentThread(), после чего можно управлять потоком.

В классе Thread определены семь перегруженных конструкторов, большое количество методов,
предназначенных для работы с потоками, и три константы (приоритеты выполнения потока).

Конструкторы класса Thread: --------------------------------------------------------------------------------------------
 - Thread();
 - Thread(Runnable target);
 - Thread(Runnable target, String name);
 - Thread(String name);
 - Thread(ThreadGroup group, Runnable target);
 - Thread(ThreadGroup group, Runnable target, String name);
 - Thread(ThreadGroup group, String name);

где:
 - target – экземпляр класса реализующего интерфейс Runnable;
 - name – имя создаваемого потока;
 - group – группа к которой относится поток.

Группы потоков удобно использовать, когда необходимо одинаково управлять несколькими потоками. -------------------------

Методы класса Thread: --------------------------------------------------------------------------------------------------
 - Метод getId() - получение идентификатора потока;
 - Метод getName() - получение имени потока;
 - Метод setName() - установка имени потока;
 - Метод getPriority() - получение приоритета потока;
 - Метод setPriority(int) - установка приоритета потока;
 - Метод getState() - определение состояния потока;

 - Метод interrupt() - прерывание выполнения потока;
 - Метод isAlive() - проверка, выполняется ли поток;
 - Метод isDaemon() - проверка, является ли поток «daemon»;
 - Метод setDaemon(bool) - установка «daemon» потока;

 - Метод join() - ожидание завершения потока;
 - Метод join(millis) - ожидание millis милисекунд завершения потока;

 - Метод run() - запуск потока, если поток был создан с использованием интерфейса Runnable;
 - Метод sleep(int) - приостановка потока на заданное время;
 - Метод start() - запуск потока.

 - Метод wait() - приостановка потока, пока другой поток не вызовет метод notify();
 - Метод wait(millis) - приостановка потока на millis милисекунд или пока другой поток не вызовет метод notify();

 - Метод notify() - «пробуждение» отдельного потока, ожидающего «сигнала»;
 - Метод notifyAll() - «пробуждение» всех потоков, ожидающих «сигнала»;

Жизненный цикл потока: -------------------------------------------------------------------------------------------------
При выполнении программы объект Thread может находиться в одном из четырех основных состояний:
 - «новый»,
 - «работоспособный»,
 - «неработоспособный»,
 - «пассивный».
При создании потока он получает состояние «новый» (NEW) и не выполняется.
Для перевода потока из состояния «новый» в «работоспособный» (RUNNABLE) следует выполнить метод start(),
вызывающий метод run().

Состояния потока: ------------------------------------------------------------------------------------------------------
Поток может находиться в одном из состояний, соответствующих элементам статически вложенного enum Thread.State:
 - NEW — поток создан, но еще не запущен;
 - RUNNABLE — поток выполняется;
 - BLOCKED — поток блокирован;
 - WAITING — поток ждет окончания работы другого потока;
 - TIMED_WAITING — поток некоторое время ждет окончания другого потока;
 - TERMINATED — поток завершен.

------------------------------------------------------------------------------------------------------------------------

1. Создание собственного потока

Что-бы создать собственный поток достаточно наследоваться от класса Thread. Так-же необходимо переопределить
метод run(). Метод run() выполняется при запуске потока. Запускается поток методом start().

public class Main {

    public static class MyThread extends Thread {
        public void run() {
            System.out.println("Mой поток запущен...");
        }
    }

    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
    }
}


------------------------------------------------------------------------------------------------------------------------

2. Интерфейс Runnable

Интерфейс Runnable является функцинальным и содержит только один метод run():

    interface Runnable {
        void run();
    }

Метод run() выполняется при запуске потока.
После определения объекта Runnable он передается в один из конструкторов класса Thread.

    public class Main {

        @SneakyThrows(InterruptedException.class)
        public static void threadAction(Thread thread) {
            for (int i = 0; i < 5; i++) {
                Thread.sleep(1000);
                System.out.println("- " + thread.getName() + ": " + i);
            }

            System.out.println(thread.getName() + " завершён");
        }

        public static void main(String[] args) {
            Thread mainThread = Thread.currentThread();
            mainThread.setName("Главный поток");

            System.out.println("\nСоздан " + mainThread.getName().toLowerCase());

            new MyThread("Дополнительный поток");

            Main.threadAction(mainThread);
        }
    }

    class MyThread implements Runnable {

        String name;
        Thread thread;

        public MyThread(String name) {
            this.thread = new Thread(this, name);
            this.name = name;
            System.out.println("Создан " + this.name.toLowerCase());
            this.thread.start();
        }

        @Override
        public void run() {
            Main.threadAction(this.thread);
        }
    }

------------------------------------------------------------------------------------------------------------------------

3. Синхронизация потоков, synchronized

В процессе функционирования потоки часто используют общие ресурсы приложения, определенные вне потока.
Если несколько потоков начнут одновременно вносить изменения в общий ресурс, то результаты выполнения программы
могут быть непредсказуемыми.

Оператор synchronized позволяет определить блок кода или метод, который должен быть доступен только одному потоку.
Можно использовать synchronized в своих классах определяя синхронизированные методы или блоки.
Но нельзя использовать synchronized в переменных или атрибутах в определении класса.

3.1. Блокировка на уровне объекта

Блокировать общий ресурс можно на уровне объекта, но нельзя использовать для этих целей примитивные типы.

    synchronized (оbject) {
        // other thread safe code
    }

Общий ресурс будет блокироваться как только его захватит один из потоков;
остальные потоки будут ждать в очереди освобождения ресурса.

3.2. Блокировка на уровне метода и класса

Если во время выполнения программы имеется несколько экземпляров класса, то только один поток может выполнить метод,
для других потоков доступ к методу будет заблокирован.
Это необходимо когда требуется сделать определенные ресурсы потокобезопасными.

    public synchronized static void demoMethod() {
        // ...
    }
    -- ИЛИ --
    public void demoMethod() {
        synchronized (DemoClass.class) {
            // ...
        }
    }

Каждый объект в Java имеет ассоциированный с ним монитор, который представляет инструмент управления доступом к объекту.
Когда выполнение кода доходит до оператора synchronized, монитор объекта блокируется, предоставляя монопольный доступ
к блоку кода только одному потоку, который произвел блокировку.
После окончания работы блока кода, монитор объекта освобождается и он становится доступным для других потоков.

 - Синхронизация в Java гарантирует, что два потока не могут выполнить синхронизированный метод одновременно.
 - Оператор synchronized можно использовать только с методами и блоками кода, которые могут быть как статическими,
   так и не статическими.
 - Если один из потоков начинает выполнять синхронизированный метод или блок, то этот метод/блок блокируются.
   Когда поток выходит из синхронизированного метода или блока - JVM снимает блокировку.
   Блокировка снимается, даже если поток покидает синхронизированный метод после завершения из-за каких-либо ошибок или исключений.
 - Синхронизация в Java вызывает исключение NullPointerException, если объект, используемый в синхронизированном блоке,
   не определен, т.е. равен null.
 - Синхронизированные методы в Java вносят дополнительные затраты на производительность приложения.
   Поэтому следует использовать синхронизацию, когда она абсолютно необходима.
 - В соответствии со спецификацией языка нельзя использовать synchronized в конструкторе - это приведет к ошибке компиляции.

Для синхронизации потоков можно использовать объекты синхронизации Synchronizer's пакета java.util.concurrent.

3.3. Взаимная блокировка

С использованием блокировок необходимо быть очень внимательным, чтобы не создать «взаимоблокировку».
Этот термин означает, что один из потоков ждет от другого освобождения заблокированного им ресурса, в то время как сам
также заблокировал один из ресурсов, доступа к которому ждёт второй поток.
В данном процессе могут участвовать два и более потоков.

Основные условия возникновения взаимоблокировок в многопотоковом приложении:
 - наличие ресурсов, которые должны быть доступны только одному потоку в произвольный момент времени;
 - при захвате ресурса поток пытается захватить еще один уникальный ресурс;
 - отсутствует механизм освобождения ресурса при продолжительном его удержании;
 - во время исполнения несколько потоков могут захватить разные уникальные ресурсы и ждать друг от друга их освобождения.

------------------------------------------------------------------------------------------------------------------------

4. Взаимодействие между потоками в Java, wait и notify

При взаимодействии потоков часто возникает необходимость приостановки одних потоков и их последующего извещения о
завершении определенных действий в других потоков. Для подобных ситуаций используются методы:

 - wait() - освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток
   не вызовет метод notify();
 - notify() - продолжает работу потока, у которого ранее был вызван метод wait();
 - notifyAll() - возобновляет работу всех потоков, у которых ранее был вызван метод wait().

Все эти методы вызываются только из синхронизированного контекста (синхронизированного блока или метода). --------------

    public class Store {

        private int counter = 0;

        @SneakyThrows(InterruptedException.class)
        public synchronized void get() {
            while (this.counter < 1) {
                wait();
            }

            this.counter--;
            System.out.println("-1 : товар забрали");
            System.out.println("\tколичество товара на складе : " + this.counter);
            notify();
        }

        @SneakyThrows(InterruptedException.class)
        public synchronized void put() {
            while (this.counter >= 3) {
                wait();
            }

            this.counter++;
            System.out.println("+1 : товар добавили");
            System.out.println("\tколичество товара на складе : " + this.counter);
            notify();
        }
    }

Класс Store содержит два синхронизированных метода для получения товара get() и для добавления товара put().
При получении товара выполняется проверка счетчика counter.
Если на складе товара нет, то есть counter < 1, то вызывается метод wait(), который освобождает монитор объекта Store и
блокирует выполнение метода get(), пока для этого монитора не будет вызван метод notify().

При добавлении товара также выполняется проверка количества товара на складе.
Если на складе больше 3 единиц товара, то поставка товара приостанавливается и вызывается метод notify(), который
передает управление методу get() для завершения цикла while().

------------------------------------------------------------------------------------------------------------------------

4.1 ReentrantLock - замена synchronized

public static Lock lock = new ReentrantLock();

lock.lock();
-- логика --
lock.unlock();

при наличии нескольких потоков

while (true) {
    if (lock.tryLock()) {
        -- логика --
        break;
    } else {
        Thread.sleep(1);
        System.out.println("Thread waiting...");
    }
}
------------------------------------------------------------------------------------------------------------------------

5. Поток-демон, daemon

Java приложение завершает работу тогда, когда завершает работу последний его поток. Даже если метод main() уже завершился,
но еще выполняются порожденные им потоки, система будет ждать их завершения.

Однако это правило не относится к потокам-демонам (daemon). Если завершился последний обычный поток процесса, и остались
только daemon потоки, то они будут принудительно завершены и выполнение приложения закончится.
Чаще всего daemon потоки используются для выполнения фоновых задач, обслуживающих процесс в течение его жизни.

Daemon потоки - это потоки с низким приоритетом, чья единственная роль заключается в предоставлении услуг потокам пользователя.

Объявить поток демоном достаточно просто. Для этого нужно перед запуском потока вызвать его метод setDaemon(true).
Проверить, является ли поток daemon'ом можно вызовом метода isDaemon().
В качестве примера использования daemon-потока можно рассмотреть класс Trade, который принял бы следующий вид:

public class Trade {

    public static void main(String[] args) {
        Producer producer = new Producer(store);
        Consumer consumer = new Consumer(store);

        Thread tp = new Thread(producer);
        Thread tc = new Thread(consumer);

        tp.setDaemon(true);
        tc.setDaemon(true);

        tp.start();
        tc.start();

        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {}

        System.out.println("\nГлавный поток завершен\n");
        System.exit(0);
    }
}

Метод setDaemon () может быть вызван только после того, как объект Thread был создан и поток не был запущен.
Попытка вызова setDaemon () во время работы потока вызовет IllegalThreadStateException.

Потоки демона полезны для фоновых задач поддержки, таких как сборка мусора, освобождение памяти от неиспользуемых объектов
и удаление ненужных записей из кэша. Большинство потоков JVM являются потоками демонов.


------------------------------------------------------------------------------------------------------------------------

6. Thread и Runnable, что выбрать ?

Реализация интерфейса Runnable используется в случаях, когда класс уже наследует какой-либо родительский класс и
не позволяет расширить класс Thread. К тому же хорошим тоном программирования в java считается реализация интерфейсов.
Это связано с тем, что в java может наследоваться только один родительский класс.
Таким образом, унаследовав класс Thread, невозможно наследовать какой-либо другой класс.

Расширение класса Thread целесообразно использовать в случае необходимости переопределения других методов класса
помимо метода run().

------------------------------------------------------------------------------------------------------------------------

7. Приоритеты выполнения и голодание

Иногда разработчики используют приоритеты выполнения потока. В Java есть планировщик потоков (Thread Scheduler),
который контролирует все запущенные потоки и решает, какие потоки должны быть запущены и какая строка кода должна
выполняться. Решение основывается на приоритете потока. Поэтому потоки с меньшим приоритетом получают меньше
процессорного времени по сравнению с потоками с бо́льшим приоритет. Данное разумное решением может стать причиной проблем
при злоупотреблении. То есть, если бо́льшую часть времени исполняются потоки с высоким приоритетом, то низкоприоритетные
потоки начинают «голодать», поскольку не получают достаточно времени для того, чтобы выполнить свою работу должным образом.
Поэтому рекомендуется задавать приоритет потока только тогда, когда для этого имеются веские основания.

Неочевидный пример «голодания» потока даёт метод finalize(), предоставляющий возможность выполнить код перед тем, как
объект будет удалён сборщиком мусора. Однако приоритет финализирующего потока невысокий.
Следовательно, возникают предпосылки для потокового голодания, когда методы finalize() объекта тратят слишком много
времени (большие задержки) по сравнению с остальным кодом.

Другая проблема со временем исполнения может возникнуть от того, что не был определен порядок прохождения потоком
блока synchronized. Когда несколько параллельных потоков должны выполнить некоторый код, оформленный блоком synchronized,
может получиться так, что одним потокам придётся ждать дольше других, прежде чем войти в блок.
Теоретически они могут вообще туда не попасть.
