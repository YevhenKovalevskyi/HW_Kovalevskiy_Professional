Оператор ==

В Java оператор == возвращает значение типа boolean - результат сравнения экземпляров объектов, либо примитивов.
Поведение операции сравнения зависит от типов её операндов (объектных, либо примитивных типов).

------------------------------------------------------------------------------------------------------------------------

Сравнение объектов

Если оба операнда являются экземплярами объектных типов, то данный оператор просто проверяет равенство ссылок
(указывают ли ссылки, значения которых хранятся в сравниваемых переменных, на один и тот-же объект в Heap'е),
а не сравнивает на равенство внутреннее содержимое объектов.

Таким образом, при сравнении объектов в Java оператор == вернет true лишь в том случае,
когда ссылки указывают на один и тот-же объект из heap (кучи).

------------------------------------------------------------------------------------------------------------------------

Сравнение примитивов

Сравнение примитивных типов происходит в следующих ситуациях:
 - оба операнда являются экземплярами примитивных типов (byte, short, int, long, char, float, либо double);
 - если хотя бы один из операндов являются экземпляром примитивного типа (byte, short, int, long, char, float, либо double),
   а второй является экземпляром объектного типа обертки (Wrapper Class) над примитивным (Byte, Short, Integer, Long, Character, Float, Double),
   то отработает механизм autounboxing (у экземпляра объектного типа будет вызван соответствующий
   этому типу метод: byteValue(), shortValue(), intValue(), longValue(), charValue(), floatValue(), либо doubleValue()),
   после чего мы получаем два экземпляра примитивных типов (возможно, разных - см. следующий абзац, подробнее см. здесь).

Алгоритм сравнения:

Сначала операнды распространяются (т.е. происходит "арифметическое распространение (promotion) операндов") до наибольшего,
если это необходимо (если операнды являются экземплярами разных примитивных типов),
а затем происходит непосредственное побитовое сравнение (если все биты равны, то возвращаемое значение будет true, иначе - false).

Контрольный пример:

Например, значение 48.0f (типа float, соответственно) равно значению '0'
(код которого равен 48 согласно таблице символов Unicode) типа char, значение которого неявно распространяется до типа float.

char char1 = '0';
int int1 = 48;
float float1 = 48.0F;
Integer integer1 = 48; // произойдет вызов: Integer.valueOf(48);
System.out.println(char1 == int1);    // true
System.out.println(char1 == float1);  // true
System.out.println(int1 == float1);   // true
System.out.println(int1 == integer1); // true (произойдет вызов: integer1.intValue();)

// ---------------------------------------------

char char2 = 'A';
long long2 = 65L;
float float2 = 65.0F;
Long longInteger2 = 65L; // произойдет вызов: Long.valueOf(65L);
System.out.println(char2 == long2);        // true
System.out.println(char2 == float2);       // true
System.out.println(long2 == float2);       // true
System.out.println(long2 == longInteger2); // true (произойдет вызов: longInteger2.longValue();)

------------------------------------------------------------------------------------------------------------------------

Сравнение вещественных примитивов

Для вещественных примитивов (float и double) существуют некоторые особенности, которые необходимо учитывать.
Представление вещественных чисел в Java соответствует стандарту IEEE 754, т.е.
число представлено в виде мантисы (значимой части) и порядка (степени, в которую возводится основание/база системы)
откуда следует то, что как целая, так и дробная часть числа представлены с помощью конечного числового ряда 2^(n),
где как максимальное, так и минимальное значение числа n зависят от размера мантисы и порядка, которые, в свою очередь,
зависят от конкретного типа (float, double). Как следствие, о точном представлении произвольно взятого числа говорить не приходится.

Само собой разумеется, что две вещественные переменные, проинициализированные одним и тем же вещественным литералом,
будут равны (ведь они проинициализировались одной и той же последовательностью бит):

float float1 = 0.7F;
float float2 = 0.7F;

System.out.println(float1 == float2); // true

Но стоит начать выполнять арифметические операции с переменными данного типа, как, скорее всего,
начнет накапливаться погрешность вычислений (из-за указанных выше особенностей представления экземпляров данного типа):

float float1 = 0.7F;
float float2 = 0.3F + 0.4F;

System.out.println(float1 == float2); // false
System.out.println(float1);           // 0.7
System.out.println(float2);           // 0.70000005

Как следует сравнивать вещественные примитивы --------------------------------------------------------------------------

Вещественные примитивы (float и double) стоит сравнивать с определенной точностью.
Например, округлять их до 6-го знака после запятой (1E-6 для double, либо 1E-6F для float), либо, что предпочтительнее,
проверять абсолютное значение разницы между ними.

Контрольный пример:

float float1 = 0.7F;
float float2 = 0.3F + 0.4F;
final float EPS = 1E-6F;

System.out.println(Math.abs(float1 - float2) < EPS); // true

------------------------------------------------------------------------------------------------------------------------

Альтерантивы оператору ==

Для сравнения двух экземпляров объектных типов в Java также существуют такие методы как: equals() и hashCode().
Методы hashCode() и equals() определены в классе java.lang.Object, который является родительским классом для объектов Java,
поэтому все Java-объекты наследуют от этих методов реализацию по умолчанию.

Использование equals() и hashCode() ------------------------------------------------------------------------------------

 - Метод equals(), как и следует из его названия, используется для простой проверки равенства двух объектов.
   Реализация этого метода, по умолчанию, проверяет равенство ссылок двух объектов, т.е. по умолчанию,
   поведение идентично работе оператора == за исключением того,
   что оператор == не позволяет сравнивать операнды неприводимых друг к другу типов.

 - Метод hashCode() обычно используется для получения уникального целого числа, что на самом деле не является правдой,
   т.к. результат работы данного метода - это целое число примитивного типа int (называемое хеш-кодом),
   полученное посредством работы хэш-функции входным параметром которой является объект, вызывающий данный метод,
   но множество возможных хеш-кодов ограничено примитивным типом int (всего 2^32 вариантов значений),
   а множество объектов ограничено только нашей фантазией.

Из вышеописанного между методами hashCode() и equals() следует следующий контракт:
 - если хеш-коды разные, то и объекты гарантированно разные;
 - если хеш-коды равны, то входные объекты могут быть неравны
   (это обусловленно тем, что множество объектов мощнее множества хеш-кодод,
   т.к. множество возможных хеш-кодов ограничено размером примитивного типа int).

------------------------------------------------------------------------------------------------------------------------

 - int хранит целые числа с абсолютной точностью, т.к. из 32 бит лишь 1 бит используется для определения знака числа,
   а остальные 31 для непосредственного кодирования его значения;
 - float с абсолютной точностью может хранить лишь 24 бита (23 бита мантисы + 1 зарезервированный бит),
   а остальные 9 (= 32 - 23) битов используются для определения порядка (8 бит) и знака числа (1 бит).

------------------------------------------------------------------------------------------------------------------------

Подведем итоги

Если вам необходимо проверить не ссылаются ли две переменных на один и тот же объект, либо сравнить на равенство два примитива,
то вам определенно стоит воспользоваться оператором == (при этом стоит иметь в виду то, что вещественные числа следует сравнить
лишь с определенной точностью), но если же вам необходимо сравнить именно внутреннее содержимое объектов
(либо основываясь на каком-нибудь нестандартном алгоритме), на которые ссылаются данные переменные,
то вам стоит воспользоваться методом equals() соответствующего класса (причем если вы в своем классе переопределяете метод equals(),
то при этом вам также стоит не забыть переопределить метод hashCode() согласно вышеописанному контракту между ними).
