В Java основной функционал работы с потоками сосредоточен в классах из пакета java.io.

Ключевым понятием здесь является понятие потока. В данном случае применительно к работе с файлами и вводом-выводом
мы будем говорить о потоке (stream), как об абстракции, которая используется для чтения или записи информации
(файлов, сокетов, текста консоли и т.д.).

Поток связан с реальным физическим устройством с помощью системы ввода-вывода Java. У нас может быть определен поток,
который связан с файлом и через который мы можем вести чтение или запись файла. Это также может быть поток,
связанный с сетевым сокетом, с помощью которого можно получить или отправить данные в сети.
Все эти задачи: чтение и запись различных файлов, обмен информацией по сети, ввод-ввывод в консоли решаются в Java
с помощью потоков.

Объект, из которого можно считать данные - поток ввода, а объект, в который можно записывать данные, - потоком вывода.
Например, если надо считать содержание файла, то применяется поток ввода, а если надо записать в файл - то поток вывода.

------------------------------------------------------------------------------------------------------------------------

1. В основе всех классов, управляющих потоками байтов, находятся два абстрактных класса:
!!! InputStream !!! (потоки ввода) и !!! OutputStream !!! (потоки вывода).

2. Поскольку работать с байтами не очень удобно, то для работы с потоками символов были добавлены абстрактные классы:
!!! Reader !!! (для чтения потоков символов) и !!! Writer !!! (для записи потоков символов).

Все остальные классы, работающие с потоками, являются наследниками этих абстрактных классов. Основные классы потоков:
| --- InputStream ---- | --- OutputStream --- | --- Reader ---- | --- Writer ---- |
| FileInputStream      | FileInputStream      | FileReader      | FileWriter      |
| BufferedInputStream  | BufferedInputStream  | BufferReader    | BufferWriter    |
| ByteArrayInputStream | ByteArrayInputStream | CharArrayReader | CharArrayWriter |
| FilterInputStream    | FilterInputStream    | FilterReader    | FilterWriter    |
| DataInputStream      | DataInputStream      |                 |                 |
| ObjectInputStream    | ObjectInputStream    |                 |                 |

------------------------------------------------------------------------------------------------------------------------

Потоки байтов

Класс InputStream является базовым для всех классов, управляющих байтовыми потоками ввода. -----------------------------
 - Метод available(): возвращает количество байтов, доступных для чтения в потоке
 - Метод close(): закрывает поток
 - Метод read(): возвращает целочисленное представление следующего байта в потоке. Когда в потоке не останется
   доступных для чтения байтов, данный метод возвратит число -1
 - Метод read(byte[] buffer): считывает байты из потока в массив buffer. После чтения возвращает число считанных байтов.
   Если ни одного байта не было считано, то возвращается число -1
 - Метод read(byte[] buffer, int offset, int length): считывает некоторое количество байтов, равное length, из потока в
   массив buffer. При этом считанные байты помещаются в массиве, начиная со смещения offset, то есть с элемента buffer[offset].
   Метод возвращает число успешно прочитанных байтов.
 - Метод skip(long number): пропускает в потоке при чтении некоторое количество байт, которое равно number

Класс OutputStream является базовым классом для всех классов, которые работают с бинарными потоками записи. ------------
 - Метод close(): закрывает поток
 - Метод flush(): очищает буфер вывода, записывая все его содержимое
 - Метод write(int b): записывает в выходной поток один байт, который представлен целочисленным параметром b
 - Метод write(byte[] buffer): записывает в выходной поток массив байтов buffer.
 - Метод write(byte[] buffer, int offset, int length): записывает в выходной поток некоторое число байтов, равное length,
   из массива buffer, начиная со смещения offset, то есть с элемента buffer[offset].

------------------------------------------------------------------------------------------------------------------------

Потоками символов

Абстрактный класс Reader предоставляет функционал для чтения текстовой информации. -------------------------------------
 - Метод close(): закрывает поток ввода
 - Метод read(): возвращает целочисленное представление следующего символа в потоке. Если таких символов нет,
   и достигнут конец файла, то возвращается число -1
 - Метод read(char[] buffer): считывает в массив buffer из потока символы, количество которых равно длине массива buffer.
   Возвращает количество успешно считанных символов. При достижении конца файла возвращает -1
 - Метод read(CharBuffer buffer): считывает в объект CharBuffer из потока символы. Возвращает количество успешно
   считанных символов. При достижении конца файла возвращает -1
 - Метод read(char[] buffer, int offset, int count): считывает в массив buffer, начиная со смещения offset,
   из потока символы, количество которых равно count
 - Метод skip(long count): пропускает количество символов, равное count. Возвращает число успешно пропущенных символов

Класс Writer определяет функционал для всех символьных потоков вывода. -------------------------------------------------
 - Метод append(char c): добавляет в конец выходного потока символ c. Возвращает объект Writer
 - Метод append(CharSequence chars): добавляет в конец выходного потока набор символов chars. Возвращает объект Writer
 - Метод close(): закрывает поток
 - Метод flush(): очищает буферы потока
 - Метод write(int c): записывает в поток один символ, который имеет целочисленное представление
 - Метод write(char[] buffer): записывает в поток массив символов
 - Метод write(char[] buffer, int off, int len) : записывает в поток только несколько символов из массива buffer.
   Причем количество символов равно len, а отбор символов из массива начинается с индекса off
 - Метод write(String str): записывает в поток строку
 - Метод write(String str, int off, int len): записывает в поток из строки некоторое количество символов,
   которое равно len, причем отбор символов из строки начинается с индекса off

Функционал, описанный классами Reader и Writer, наследуется непосредственно классами символьных потоков,
в частности классами FileReader и FileWriter соответственно, предназначенными для работы с текстовыми файлами.

------------------------------------------------------------------------------------------------------------------------

Краткий список недостатков первой I/O API:
 - Классу File не хватало функциональности. Например не было метода copy для копирования файла/каталога.
 - В классе File определено много методов, которые возвращают Boolean-значение. В случае ошибки, возвращалось false,
   а не бросалось исключение, что затрудняло обнаружение и исправление ошибок.
 - Класс File не предоставляет хорошей обработки символьных ссылок.
 - Класс File обрабатывает файлы/каталоги неэффективно (проблемы с масштабированием);
 - Класс File предоставляет доступ к ограниченному набору атрибутов файлов, который зачастую недостаточен.

Для преодоления этих проблем, в Java 4 введен NIO (New IO). Ключевые особенности NIO:
    Каналы и селекторы:
      NIO поддерживает различные типы каналов. Канал является абстракцией объектов более низкого уровня файловой системы
      (например, отображенные в памяти файлы и блокировки файлов), что позволяет передавать данные с более высокой скоростью.
      Каналы не блокируются и поэтому Java предоставляет еще такие инструменты, как селектор, который позволяет выбрать
      готовый канал для передачи данных, и сокет, который является инструментом для блокировки.
    Буферы:
      в Java 4 была введена буферизация для всех классов-обёрток примитивов (кроме Boolean).
      Появился абстрактный класс Buffer, который предоставляет такие операции, как clear, flip, mark и т.д.
      Его подклассы предоставляют методы для получения и установки данных.
    Кодировки:
      в Java 4 появились кодировки (java.nio.charset), кодеры и декодеры для отображения байт и символов Unicode.

В Java 7 был введён пакет java.nio.file для лучшей поддержки и обработки символьных ссылок, полного доступа
к атрибутам и работы с файловой системой через интерфейсы или классы, такие как Path, Paths, and Files.

------------------------------------------------------------------------------------------------------------------------
