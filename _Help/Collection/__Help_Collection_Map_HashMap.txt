HashMap - класс, реализует интерфейс Map и наследуется от класса AbstractMap.
AbstractMap - абстрактный, базовый класс для всех Map. Реализует большую часть методов интерфейса Map.

Реализация основана на принципах хеш-таблицы. Пары ключ-значение хранятся в так называемых сегментах,
которые вместе составляют таблицу, которая на самом деле является внутренним массивом.

Хэш-функция — это функция, сужающая множество значений объекта до некоторого подмножества целых чисел.

Как только мы узнаем ключ, под которым хранится или должен быть сохранен объект,
операции хранения и поиска выполняются за постоянное время, O(1) в хэш-карте с большими размерами.

------------------------------------------------------------------------------------------------------------------------

Конструкторы HashMap:

  // Создание пустой карты начальной емкостью (16) и со значением коэффициента загрузки (0.75) по умолчанию
  public HashMap();

  // Создание карты из элементов карты
  public HashMap(Map<? extends K, ? extends V> m) {

  // Создание карты с указанной начальной емкостью и со значением коэффициента загрузки по умолчанию (0.75)
  public HashMap(int initialCapacity);

  // Создание карты с указанными начальной емкостью и коэффициентом загрузки
  public HashMap(int initialCapacity, float loadFactor);

  HashMap<K, V> hashMap = new HashMap<>();

------------------------------------------------------------------------------------------------------------------------

2. API put () ----------------------------------------------------------------------------------------------------------
Чтобы сохранить значение в хэш-карте, мы вызываем API put, который принимает два параметра: ключ и значение:
 - V put(K key, V value);

1. Когда значение value добавляется на карту под ключом key, вызывается API hashCode() объекта ключа для получения
так называемого !!! начального значения хеш-функции. !!! ---------------------------------------------------------------
2. Затем, API hash() вызывается вычисления !!! окончательного значения хеш-функции !!!
с использованием !!! начального значения хеш-функции. !!! --------------------------------------------------------------

static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

Это окончательное хеш-значение в конечном итоге сводится к индексу во внутреннем массиве или к тому,
что мы называем расположением сегмента.

Находясь внутри функции put, окончательное значение хеша используется следующим образом:

public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

hash(key) - окончательное значение хеш-функции.

хеш-карты хранят и ключ, и значение в расположении корзины как объект Map.Entry.
Карты точно не хранят отдельные элементы, как в других коллекциях, а представляют собой набор пар ключ-значение.
Таким образом, универсальные методы интерфейса Collection, такие как add, toArray, не имеют смысла в Map.

Когда во время операции put встречается пустой ключ, ему автоматически присваивается окончательное значение
хеш-функции - 0, что означает, что он становится первым элементом базового массива.
Это также означает, что когда ключ имеет значение NULL, операция хеширования не выполняется,
следовательно, API-ключ ключа hashCode не вызывается, что в конечном итоге исключает исключение нулевого указателя.

Во время операции put, когда мы используем ключ, который уже использовался ранее для хранения значения,
он возвращает предыдущее значение, связанное с ключом, в противном случае возвращается null.

4. Итераторы -----------------------------------------------------------------------------------------------------------
Если на карте произведено какое-либо структурное изменение, то после создания итератора будет сгенерировано
исключение одновременного изменения: ConcurrentModificationException

Set<String> keys = map.keySet();
Iterator<String> it = keys.iterator();
map.remove("type");

while (it.hasNext()) {
    String key = it.next();
}

Единственная разрешенная структурная модификация - это операция remove, выполняемая самим итератором.

Set<String> keys = map.keySet();
Iterator<String> it = keys.iterator();

while (it.hasNext()) {
    it.next();
    it.remove();
}


5. Производительность HashMap ------------------------------------------------------------------------------------------
На производительность хэш-карты влияют два параметра: Initial Capacity и Load Factor.
Емкость - это количество сегментов или длина базового массива, а начальная емкость - просто емкость во время создания.
Коэффициент загрузки или LF - это мера того, насколько полной должна быть карта хеша после добавления некоторых значений
до ее изменения.
Начальная емкость по умолчанию - 16, а коэффициент загрузки по умолчанию - 0.75.

Мы можем создать хэш-карту с пользовательскими значениями для начальной емкости и LF:

Map<String,String> hashMapWithCapacity=new HashMap<>(32);
Map<String,String> hashMapWithCapacityAndLF=new HashMap<>(32, 0.5f);

Значения по умолчанию, установленные командой Java, хорошо оптимизированы для большинства случаев.
Тем не менее, если вам нужно использовать свои собственные значения, что очень хорошо,
вам нужно понимать влияние на производительность, чтобы вы знали, что делаете.

Когда количество записей в хэш-карте превышает произведение LF и емкости, происходит перефразировка, т.е.
Создается другой внутренний массив с удвоенным размером исходного и все записи перемещаются в новые области памяти в новом массиве ,
 - Низкая начальная емкость снижает стоимость помещения, но увеличивает частоту перефразирования **.
 - Перефразировка, очевидно, очень дорогой процесс. Поэтому, как правило, если вы ожидаете много записей,
   вы должны установить достаточно высокую начальную емкость.

С другой стороны, если вы установите слишком высокую начальную емкость, вы заплатите стоимость за время итерации.
 - Таким образом, высокая начальная емкость хороша для большого количества записей в сочетании с минимальной итерацией.
 - Низкая начальная емкость хороша для нескольких записей с большим количеством итераций ** .

6. Столкновения в HashMap ----------------------------------------------------------------------------------------------
Коллизия хеш-кода в HashMap, - это ситуация, когда два или более ключевых объекта выдают одно и то же окончательное
хеш-значение и, следовательно, указывают на одно и то же местоположение сегмента или индекс массива.

Этот сценарий может возникнуть из-за того, что согласно контракту equals и hashCode два неравных объекта в Java
могут иметь одинаковый хэш-код.

