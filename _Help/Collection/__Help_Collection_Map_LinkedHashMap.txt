LinkedHashMap - класс, реализует интерфейс Map и наследуется от класса HashMap.
Запоминает порядок, в котором добавлялись элементы, разрешает перебор в порядке вставки.

Симбиоз связанных списков и хэш-мапов.

Поддерживает двусвязный список, проходящий через все его записи, в дополнение к базовому массиву размера по умолчанию 16.
Чтобы поддерживать порядок элементов, LinkedHashMap модифицирует класс Map.Entry HashMap,
добавляя указатели на следующие и предыдущие записи: before и after, которые позволяют ему подключаться к связанному списку.

------------------------------------------------------------------------------------------------------------------------

объект linkedHashMap, помимо свойств унаследованных от HashMap
(такие как table, loadFactor, threshold, size, entrySet и т.п.), так же содержит два доп. свойства:

 - header — «голова» двусвязного списка. При инициализации указывает сам на себя;
 - accessOrder — указывает каким образом будет осуществляться доступ к элементам при использовании итератора.
   При значении true — по порядку последнего доступа (об этом в конце статьи).
   При значении false доступ осуществляется в том порядке, в каком элементы были вставлены.

Инициализация свойства header происходит в переопределенном методе init():

void init()
{
    header = new Entry<K,V>(-1, null, null, null);
    header.before = header.after = header;
}

------------------------------------------------------------------------------------------------------------------------

1. Порядок доступа LinkedHashMap

LinkedHashMap предоставляет специальный конструктор, который позволяет нам указать среди нестандартного
коэффициента загрузки (LF) и начальной емкости, другой механизм/стратегию упорядочения, называемый access-order:

LinkedHashMap<Integer, String> map = new LinkedHashMap<>(16, .75f, true);

Первый параметр - это начальная емкость, за которой следует коэффициент загрузки, а последний параметр - это режим заказа.
Таким образом, передавая true, мы получили порядок доступа, тогда как по умолчанию был порядок вставки.
Этот механизм гарантирует, что порядок итерации элементов - это порядок, в котором к элементам обращались в последний раз,
от наименее недавнего доступа к последнему доступу.

Set<Integer> keys = map.keySet();
assertEquals("[1, 2, 3, 4, 5]", keys.toString());

map.get(4);
assertEquals("[1, 2, 3, 5, 4]", keys.toString());

map.get(1);
assertEquals("[2, 3, 5, 4, 1]", keys.toString());

map.get(3);
assertEquals("[2, 5, 4, 1, 3]", keys.toString());

Обратите внимание, как изменяется порядок элементов в наборе ключей при выполнении операций доступа на карте.
!!! Только явные операции доступа на карте будут влиять на порядок. !!!

------------------------------------------------------------------------------------------------------------------------

 - Метод removeEldestEntry() - может быть переопределен для применения политики автоматического удаления устаревших элементов.
   @Override
   protected boolean removeEldestEntry(Map.Entry eldest) {
       return size() > MAX__ENTRIES;
   }
   в случае выхода карты за размер MAX__ENTRIES, с каждым добавлением новых - будут удаляться старые элементы.

------------------------------------------------------------------------------------------------------------------------

5. Вопросы производительности

Точно так же, как HashMap, LinkedHashMap выполняет основные операции Map добавления, удаления и хранения в постоянном времени,
пока хеш-функция имеет большие размеры. Он также принимает нулевой ключ, а также нулевые значения.

Тем не менее, эта постоянная производительность LinkedHashMap, вероятно, будет немного хуже, чем постоянная HashMap
из-за дополнительных издержек на поддержание двусвязного списка.

Итерация по представлениям коллекции LinkedHashMap также занимает линейное время O(n), аналогичное тому, что у HashMap.
С другой стороны, линейное время LinkedHashMap во время итерации лучше, чем линейное время HashMap.

Это связано с тем, что для LinkedHashMap n в O (n) - это только количество записей на карте независимо от емкости.
Принимая во внимание, что для HashMap n - это емкость, а размер суммируется, O (размер + емкость).

Коэффициент загрузки и начальная емкость определяются точно так же, как для HashMap.

Однако, что штраф за выбор чрезмерно высокого значения для начальной емкости для LinkedHashMap менее строг,
чем для HashMap, поскольку время итерации для этого класса не зависит от емкости.

------------------------------------------------------------------------------------------------------------------------

6. Параллелизм

Так же, как HashMap, реализация LinkedHashMap не синхронизирована.
Таким образом, если вы собираетесь обращаться к нему из нескольких потоков, и хотя бы один из этих потоков
может изменить его структурно, то он должен быть синхронизирован извне.

Лучше всего сделать это при создании:
Map m = Collections.synchronizedMap(new LinkedHashMap());

Разница с HashMap заключается в том, что влечет за собой структурную модификацию. В упорядоченных связанных хеш-картах
простой вызов API get приводит к структурной модификации. Наряду с этим, такие операции, как put и remove.

------------------------------------------------------------------------------------------------------------------------

Вообще, из-за того что всю основную работу на себя берет родительский класс, серьезных отличий в реализации
HashMap и LinkedHashMap не много. Можно упомянуть о парочке мелких:

 - Методы transfer() и containsValue() устроены чуть проще из-за наличия двунаправленной связи между элементами;
 - В классе LinkedHashMap.Entry реализованы методы recordRemoval() и recordAccess()
   (тот самый, который помещает элемент в конец при accessOrder = true). В HashMap оба этих метода пустые.
