Метод clone()

Цель этого метода – клонировать объект – т.е. создать его клон/копию/дубликат.
Если его вызвать, то Java-машина создаст и вернет дубликат объекта, у которого вызвали этот метод.
Клонирование объекта в классе Object реализовано очень примитивно – при клонировании создается всего один новый объект:
 - просто создается еще один объект и его полям присваиваются значения полей объекта-образца.
Если копируемый объект содержит ссылки на другие объекты, то ссылки будут скопированы, дубликаты тех объектов не создаются.

Java-машина не знает, какие объекты можно клонировать, а какие нет. Файлы и поток System.in, например, клонировать нельзя.

Поэтому вопрос о полноценном клонировании был отдан на откуп разработчикам классов.

------------------------------------------------------------------------------------------------------------------------

Интерфейс Cloneable – это так называемый интерфейс-маркер, который не содержит никаких методов.

Если разработчик класса считает, что объекты класса можно клонировать, он наследует класс от Cloneable.
Если разработчика не устраивает стандартная реализация метода clone, он должен написать свою,
которая будет создавать дубликат объекта "правильным" образом.

При вызове метода clone(), Java проверяет, был ли у объекта интерфейс Cloneable.
Если да — клонирует объект методом clone(), если нет — выкидывает исключение CloneNotSupportedException.

 - воспользоваться «клонированием по умолчанию»
    а) Добавить интерфейс Cloneable своему классу
    б) Переопределить метод clone и вызвать в нем базовую реализацию:
        class Point implements Cloneable {
            int x;
            int y;

            @Override
            public Object clone() {
                return super.clone();
            }
        }
 - написать свое «клонирование»
    а) Добавить интерфейс Cloneable своему классу
    б) Переопределить метод clone и задействовать свою реализацию:
        class Point implements Cloneable {
            int x;
            int y;

            @Override
            public Object clone() {
                Point point = new Point();
                point.x = this.x;
                point.y = this.y;

                return point;
            }
        }

------------------------------------------------------------------------------------------------------------------------

Для клонирования объекта в Java можно пользоваться такими способами:

 1.1 Поверхностное клонирование ----------------------------------------------------------------------------------------
   Переопределение метода clone() и реализация интерфейса Cloneable();
   @Override
   protected Person clone() throws CloneNotSupportedException {
       return (Person) super.clone();
   }

 1.2 Глубокое клонирование ---------------------------------------------------------------------------------------------
   Если поля Класса сами являются объектами: имплементим им Cloneable(), добавляем им метод clone() и правим крайний clone()
   @Override
   protected Person clone() throws CloneNotSupportedException {
       Person person = (Person) super.clone();
       person.address = this.getAddress().clone();
       return person;
   }

 2.1 Конструктор копирования (поверхностное клонирование) --------------------------------------------------------------
   public Person(int age, String name) {
       this.age = age;
       this.name = name;
   }

   // конструктор копии
   public Person(Person other) {
       this(other.getAge(), other.getName());
   }
   В классе описывается конструктор, который принимает объект этого же класса и инициализирует значениями его полей
   поля нового объекта.

 2.2 Конструктор копирования (глубокое клонирование) -------------------------------------------------------------------
   public Person (Person person) {
       this(person.getId(), person.getName(), person.getAddress().clone());
   }

   + в классах полей делаем то же самое
   public Address(Address a) {
       this(a.getStreet(), a.getHouse());
   }

 3. Фабрика копий(статический фабричный метод) -------------------------------------------------------------------------
   public static Person newInstance(Person person) {
       return new Person(person.getAge(), person.getName());
   }

 4. Использовать для клонирования механизм сериализации. ---------------------------------------------------------------
   Наиболее удобный и гибкий способом клонирования!
   Cat vaska = new Cat("Vaska", "Gray", 4);

   ByteArrayOutputStream baos = new ByteArrayOutputStream();
   ObjectOutputStream ous = new ObjectOutputStream(baos);

   //сохраняем состояние кота Васьки в поток и закрываем его(поток)
   ous.writeObject(vaska);
   ous.close();

   ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
   ObjectInputStream ois = new ObjectInputStream(bais);

   //создаём кота для опытов и инициализируем его состояние Васькиным
   Cat cloneVaska = (Cat)ois.readObject();

   !!! создает независимый клон, но жрет много памяти !!!

 5. Клонированию с помощью рефлексии. ----------------------------------------------------------------------------------
   public T cloneObject(T target) {
       try {
           Class<T> objectClass = (Class<T>)target.getClass();
           Field[] fields = objectClass.getDeclaredFields();

           T instance = objectClass.newInstance();

           for(Field field: fields) {
               field.setAccessible(true);
               field.set(instance, field.get(target));
           }

           return instance;
       } catch(InstantiationException | IllegalAccessException ex) {
           ex.printStackTrace();
       }
   }
   Плохой способ

 6. Паттерн Прототип. --------------------------------------------------------------------------------------------------
 Прототип — это порождающий паттерн, который позволяет копировать объекты любой сложности без привязки к их конкретным
 классам.

------------------------------------------------------------------------------------------------------------------------
