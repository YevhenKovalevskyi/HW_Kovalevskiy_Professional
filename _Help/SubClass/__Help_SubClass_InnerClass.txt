Нестатические вложенные классы называют также внутренними классами (inner).

class Outer {
    ...
    class Inner {
        ...
    }
}

Создать экземпляр внутреннего класса можно так: Outer.Inner inner = (new Outer()).new Inner(); -------------------------
Получить доступ из внутреннего класса к внешнему классу можно так: Outer.this. -----------------------------------------

 - Внутренний класс НЕ МОЖЕТ ИМЕТЬ СТАТИЧЕСКИЕ ЭЛЕМЕНТЫ !!!
 - ВНЕШНИЙ КЛАСС НЕ ИМЕЕТ ДОСТУПА К ЭЛЕМЕНТАМ ВНУТРЕННЕГО КЛАССА !!!
 - Внутренний класс имеет доступ ко всем свойствам и методам своего внешнего класса и может непосредственно ссылаться на них;
 - Внутренний класс Inner определён в области видимости внешнего класса Outer;
 - Внутренний класс можно определить НЕ ТОЛЬКО НА УРОВНЕ КЛАССА, но и ВНУТРИ метода или внутри тела цикла;
 - Внутренний класс может расширятся за счет наследования
 - Внутренний класс не становится сериализуемым автоматически только потому, что заключающий класс является сериализуемым.

Внутренние классы не могут быть созданы без экземпляра их заключающего класса, что означает, что они HOLD указатель
на экземпляр их заключающего класса, который может привести к переполнению памяти или исключению переполнения стека
из-за того, что GarbageCollector не сможет собирать мусор из заключающих классов, даже если они больше не используются.

Причина в том, что внутренний экземпляр все еще ссылается (имеет указатель) на внешний экземпляр.
Имея достаточно таких объектов в вашем проекте может закончиться память.

------------------------------------------------------------------------------------------------------------------------

Внутренний класс БЕЗ заключающего экземпляра:

class Main {

    public int method() {
        return 1;
    }

    public static Main main = new Main() {
        @Override
        public int method() {
            return 2;
        }
    };

    public static void main(String[] args) {
        System.out.println(Main.main.method); // - НЕ НУЖНО СОЗДАВАТЬ ЭКЗЕМПЛЯР ДЛЯ ДОСТУПА К КЛАССУ
        System.out.println(Main.main.id);     // - НЕ НУЖНО СОЗДАВАТЬ ЭКЗЕМПЛЯР ДЛЯ ДОСТУПА К КЛАССУ
    }
}
Здесь new Main() { ... } - это внутренний класс, определенный в статическом контексте и не имеющий заключающего экземпляра.

------------------------------------------------------------------------------------------------------------------------

Локальный внутренний класс - это внутренний класс, объявленный внутри любого блока кода.
Такой класс известен только в его содержащем блоке, поэтому он может быть создан и иметь доступ к елементам его содержащего блока.

public class MyClass {

    public void run() {
        class MyLocalClass {
            // ...
        }
    }
}

Преимущество заключается в том, что локальный экземпляр внутреннего класса привязан к конечным локальным переменным
содержащего его блока и может получить к ним доступ. Переменные сохраняют значение, которое они содержали в момент создания экземпляра,
даже если переменные вышла за пределы области видимости.

Поскольку локальный внутренний класс не является ни членом класса, ни пакетом, он не объявляется с уровнем доступа.
(Однако следует иметь в виду, что его собственные члены имеют уровни доступа, как в обычном классе.)

Если локальный внутренний класс объявлен в методе экземпляра, экземпляр внутреннего класса привязывается к экземпляру,
удерживаемому содержимым метода this во время создания экземпляра, и поэтому члены экземпляра содержащего класса доступны,
как в экземпляре внутреннего класса.

Локальный внутренний класс создается просто по названию.

------------------------------------------------------------------------------------------------------------------------

Анонимный внутренний класс - это внутренний класс но без имени.
Анонимный внутренний класс - это синтаксически удобный способ написания локального внутреннего класса.

Чаще всего локальный внутренний класс создается не более одного раза при каждом запуске содержащего его метода.
Поэтому было бы неплохо, если бы мы могли объединить локальное определение внутреннего класса и его единственный экземпляр
в одну удобную синтаксическую форму, а также было бы неплохо, если бы нам не нужно было придумывать имя для класса.
Анонимный внутренний класс допускает обе эти вещи:

new *ParentClassName*(*constructorArgs*) {*members*}

Это выражение возвращает новый экземпляр безымянного класса, который расширяет ParentClassName.
Вы не можете предоставить свой собственный конструктор; скорее, он неявно предоставляется, который просто вызывает супер конструктор,
поэтому предоставленные аргументы должны соответствовать суперконструктору.
(Если родитель содержит несколько конструкторов, то вызывается “simplest”).

Кроме того, можно указать интерфейс для реализации:

new *InterfaceName*() {*members*}

Такое объявление создает новый экземпляр безымянного класса, который расширяет объект и реализует InterfaceName.
Опять же, вы не можете предоставить свой собственный конструктор; в этом случае Java неявно предоставляет конструктор no-arg, do-nothing.

Даже если вы не можете дать анонимному внутреннему классу конструктор, вы все равно можете выполнить любую настройку,
используя блок инициализатора (блок {}, расположенный вне любого метода).

new YourClass(){}; означает class [Anonymous] extends YourClass {}
new YourInterface(){}; означает class [Anonymous] implements YourInterface {}

----- ----- -----

Анонимные классы создаются не при объявлении вложенного класса, а при создании экземпляра уже существующего типа:

Runnable runnable = new Runnable() {

    @Override
    public void run() {
        // ...
    }
};
Мы только что создали новый класс на основе интерфейса Runnable, и этот класс анонимный.

Таким же образом можно расширить другие классы, не имеющие свойства final:

List<String> customStringBuilder = new ArrayList<>(10) {

    @Override
    public boolean add(String value) {
        System.out.println("Adding value: " + value);
        return super.add(value);
    }

    // ...
};

Синтаксис создания всегда следует одной и той же структуре:

new <<Тип>>(<<аргументы конструктора>>) {
    // объявления / переопределения
};

----- ----- -----

Анонимные классы объявляются через выражения, и выражения обязательно должны быть частью оператора  —  либо в блоке,
либо в самом объявлении члена.

----- ----- -----

Анонимные классы против лямбд:

// АНОНИМНЫЙ КЛАСС
Predicate<String> anonymous = new Predicate<String>() {

    @Override
    public boolean test(String t) {
        return t != null;
    }
};

// ЛЯМБДА-ВЫРАЖЕНИЕ
Predicate<String> lambda = (input) -> input != null;

Лямбды используют операционный код invokedynamic, который позволяет JVM вызывать методы более динамическим образом.

----- ----- -----
Минусы:
 - отсутствие названий осложняет отслеживание стек-трейсов;
 - можно ввести только один тип  —  никаких дополнительных интерфейсов и тому подобного;
 - более сложный синтаксис.

------------------------------------------------------------------------------------------------------------------------

Затенение (shadowing) в разработке программного обеспечения означает повторное объявление члена в более глубокой области видимости.
Это означает, что во вложенных классах мы можем переиспользовать имена переменных, а также получать доступ
к затемненному члену с помощью префикса вызова:

public class Outer {

    String stringVal = "Outer class";

     public class Nested {
         String stringVal = "Nested Class";

         public void run() {
             System.out.println("Nested stringVal = " + this.stringVal);
             System.out.println("Outer stringVal = " + Outer.this.stringVal);
         }
     }
}
