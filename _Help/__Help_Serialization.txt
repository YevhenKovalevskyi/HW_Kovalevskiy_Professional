Сериализация - это процесс записи состояния объекта в поток(последовательность байт).
Десериализация - это процесс извлечения или восстановления состояния объекта из потока(последовательности байт).
Любой Java-объект, реализующий интерфейс Serializable, преобразуется в последовательность байт.

Сериализация очень удобна, когда идет работа со сложными объектами.
Байтовый(потоковый) формат удобен и эффективен для взаимодействя и обмена.

Должен быть универсальный и эффективный протокол передачи объектов между компонентами.
Сериализация создана для этого, и компоненты Java используют этот протокол для передачи объектов.

------------------------------------------------------------------------------------------------------------------------

1. Интерфейс Serializable

Сериализовать можно только те объекты, которые реализуют интерфейс Serializable.
Этот интерфейс не определяет никаких методов, просто он служит указателем системе, что объект, реализующий его,
может быть сериализован.

1.1 Интерфейсы-маркеры. ------------------------------------------------------------------------------------------------
Это специальные информативные интерфейсы, которые просто помечают наши классы дополнительной информацией,
в будущем полезной для JVM.

------------------

У каждого класса, реализующего Serializable, должно быть поле, содержащее уникальный идентификатор версии
сериализованного класса:

private static final long serialVersionUID = 1L; -----------------------------------------------------------------------

Значение идентификатора (в данном случае 1, но может быть любым) должно быть разным у разных классов. ------------------
Оно вычисляется по содержимому класса - полям, методам и порядку их объявления.
И если мы поменяем в нашем классе тип поля или количество полей, то идентификатор изменится.
Идентификатор тоже записывается в файл при сериализации класса.

Когда мы пытаемся провести десериализацию, то есть восстановить объект из набора байт, значение идентификатора
сравнивается со значением serialVersionUID класса в нашей программе. Если значения не совпадают, будет выброшено
исключение java.io.InvalidClassException. Чтобы избежать таких ситуаций, мы просто вручную задаем для нашего класса
этот идентификатор (иначе его значение будет непредсказуемо генерироваться компилятором).

------------------

Помимо стандартной сериализации, можно создать свою, записывающую данные в нужном формате. -----------------------------
Для этого вместо Serializable класс должен реализовывать интерфейс Externalizable с 2 методами:
writeExternal (сериализация) и readExternal (десериализация). Идентификатор в этом случае не нужен.

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeObject(this.getModel());
        out.writeObject(this.getYear());
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        this.setModel((String) in.readObject());
        this.setYear((int) in.readObject());
    }

    Вся ответственность за сериализацию и десериализацию лежит на программисте! ----------------------------------------

    Любой класс, имплементирующий интерфейс Externalizable, обязан иметь конструктор по умолчанию. ---------------------

------------------

При сериализации объекта сериализуются все объекты, на которые он ссылается в своих переменных экземпляра.
И если те объекты тоже ссылаются на третьи объекты, они тоже сериализуются. И так до бесконечности.
Все классы в этой цепочке должны быть Serializable, иначе их невозможно будет сериализовать и будет выброшено исключение.

------------------------------------------------------------------------------------------------------------------------

2. Сериализация. Класс ObjectOutputStream
Для сериализации объектов в поток используется класс ObjectOutputStream. Он записывает данные в поток.
В конструкторе он принимает ссылку на поток: ObjectOutputStream(OutputStream out)

try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("file.dat"))) {

} catch(IOException ex) {

}

------------------

Статические поля принадлежат классу (в отличие от объекта) и не сериализуются. -----------------------------------------

Поля с модификатором final сериализуются как и обычные. За одним исключением – их невозможно десериализовать
при использовании Externalizable, поскольку final-поля должны быть инициализированы в конструкторе, а после этого
в readExternal изменить значение этого поля будет невозможно.
Соответственно, если необходимо сериализовать объект с final-полем неоходимо использовать только стандартную сериализацию.

------------------

Для записи данных ObjectOutputStream использует ряд методов:

 - Метод writeObject(Object obj): записывает в поток отдельный объект. -------------------------------------------------
   Person p = new Person("Sam", 33, 178, true);
   oos.writeObject(p);

   при этом класс class Person implements Serializable { должен имплементить Serializable ------------------------------

 - Метод writeBoolean(boolean val): записывает в поток значение boolean. -----------------------------------------------

 - Метод writeChar(int val): записывает в поток значение типа char, представленное целочисленным значением. ------------

 - Метод writeDouble(double val): записывает в поток значение типа double. ---------------------------------------------

 - Метод writeFloat(float val): записывает в поток значение типа float. ------------------------------------------------

 - Метод writeInt(int val): записывает целочисленное значение int. -----------------------------------------------------

 - Метод writeLong(long val): записывает значение типа long. -----------------------------------------------------------

 - Метод writeShort(int val): записывает значение типа short. ----------------------------------------------------------

 - Метод writeUTF(String str): записывает в поток строку в кодировке UTF-8. --------------------------------------------

 - Метод write(byte[] buf): записывает в поток массив байтов. ----------------------------------------------------------

 - Метод writeByte(int val): записывает в поток один младший байт из val. ----------------------------------------------

 - Метод write(int val): записывает в поток один младший байт из val. --------------------------------------------------

 - Метод close(): закрывает поток. -------------------------------------------------------------------------------------
   oos.close();

 - Метод flush(): очищает буфер и сбрасывает его содержимое в выходной поток. ------------------------------------------
   oos.flush();

Алгоритм сериализации Java ---------------------------------------------------------------------------------------------

1. запись метаданных о классе ассоциированном с объектом
2. рекурсивная запись описания суперклассов, до тех пор пока не будет достигнут java.lang.object
3. после окончания записи метаданных начинается запись фактических данных ассоциированных с экземпляром,
   только в этот раз начинается запись с самого верхнего суперкласса
4. рекурсивная запись данных ассоциированных с экземпляром начиная с самого низшего суперкласса

------------------------------------------------------------------------------------------------------------------------

3. Десериализация. Класс ObjectInputStream
Класс ObjectInputStream отвечает за обратный процесс - чтение ранее сериализованных данных из потока.
В конструкторе он принимает ссылку на поток ввода: ObjectInputStream(InputStream in)

try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("file.dat"))) {

} catch(IOException | ClassNotFoundException ex) {

}

------------------

Для чтения данных ObjectInputStream использует ряд методов:

 - Метод readObject(): считывает из потока объект. ---------------------------------------------------------------------
   Person p = (Person) ois.readObject();

 - Метод readByte(): считывает из потока один байт. --------------------------------------------------------------------

 - Метод readChar(): считывает из потока один символ char. -------------------------------------------------------------

 - Метод readBoolean(): считывает из потока одно значение boolean. -----------------------------------------------------

 - Метод readDouble(): считывает значение типа double. -----------------------------------------------------------------

 - Метод readFloat(): считывает из потока значение типа float. ---------------------------------------------------------

 - Метод readInt(): считывает целочисленное значение int. --------------------------------------------------------------

 - Метод readLong(): считывает значение типа long. ---------------------------------------------------------------------

 - Метод readShort(): считывает значение типа short. -------------------------------------------------------------------

 - Метод readUTF(): считывает строку в кодировке UTF-8. ----------------------------------------------------------------

 - Метод read(): считывает из потока один байт и возвращает его целочисленное представление. ---------------------------

 - Метод skipBytes(int len): пропускает при чтении несколько байт, количество которых равно len. -----------------------

 - Метод available(): возвращает количество байт, доступных для чтения. ------------------------------------------------
   ois.available();

 - Метод close(): закрывает поток. -------------------------------------------------------------------------------------
   ois.close();

------------------------------------------------------------------------------------------------------------------------

4. Совместный пример:

    public static void main(String[] args) {

        String filename = "people.dat";

        // создадим список объектов, которые будем записывать
        ArrayList<Person> people = new ArrayList<Person>();
        people.add(new Person("Tom", 30, 175, false));
        people.add(new Person("Sam", 33, 178, true));

        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filename))) {
            oos.writeObject(people);
            System.out.println("File has been written");
        } catch(Exception ex) {
            System.out.println(ex.getMessage());
        }

        // десериализация в новый список
        ArrayList<Person> newPeople = new ArrayList<Person>();

        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename))) {
            newPeople = ((ArrayList<Person>) ois.readObject());
        } catch(Exception ex) {
            System.out.println(ex.getMessage());
        }

        for(Person p : newPeople) {
            System.out.printf("Name: %s \t Age: %d \n", p.getName(), p.getAge());
        }
    }

------------------------------------------------------------------------------------------------------------------------

public class Car implements Externalizable {

    private String model;
    private int year;
    private String color;
    private String drive;

    public Car() {

    }

    public Car(String model, int year, String color, String drive) {
        this.model = model;
        this.year = year;
        this.color = color;
        this.drive = drive;
    }

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeObject(this.getModel());
        out.writeObject(this.getYear());
        out.writeObject(this.getColor());
        out.writeObject(this.getDrive());
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        this.setModel((String) in.readObject());
        this.setYear((int) in.readObject());
        this.setColor((String) in.readObject());
        this.setDrive((String) in.readObject());
    }

    Setters / Getters
}

------------------------------------------------------------------------------------------------------------------------

5. Исключение данных из сериализации

По умолчанию сериализуются все переменные объекта. Однако, возможно, мы хотим, чтобы некоторые поля были исключены
из сериализации. Для этого они должны быть объявлены с модификатором transient. ----------------------------------------

class Person implements Serializable {

    private String name;
    private int age;
    private transient double height;
    private transient boolean married;

    ...

------------------------------------------------------------------------------------------------------------------------

5. Подписывание сериализованных данных

Чтобы убедиться, что данные не были изменены в файле или при пересылке по сети их можно «подписать».
Несмотря на то, что управление подписями реализовать можно и с помощью методов writeObject и readObject,
для этого есть более подходящий способ.

Если требуется зашифровать и подписать объект, то проще всего поместить его в оберточный класс javax.crypto.SealedObject
и/или java.security.SignedObject.
Данные классы являются сериализуемыми, поэтому при оборачивании объекта в SealedObject создается подобие
"подарочной упаковки" вокруг исходного объекта. Для шифрования необходимо создать симметричный ключ, управление которым
должно осуществляться отдельно.
Аналогично, для проверки данных можно использовать класс SignedObject, для работы с которым также нужен симметричный ключ,
управляемый отдельно.
Эти два объекта позволяют упаковывать и подписывать сериализованные данные, не отвлекаясь на детали проверки
и шифрования цифровых подписей.
